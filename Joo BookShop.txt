※ server = back-end / client = front-end
※ ajax 내부에 사용되는 data 변수는 대부분 반환한 응답이고, server(Controller, Service) -> client 데이터 처리

0.프젝 생성
(STS3.99, Java 11, Apache 8.5, Oracle & MySQL, MyBatis)

1. 데이터베이스 테이블 생성 및 VO 생성
   1) Oracle
   2) MySQL
   3) VO생성

2. MemberMapper.xml 추가
   1) insert 쿼리문 테스트 및 관리자 아이디 만들기
   2) mapper.xml 작성

3. MemberMapper.java 인터페이스 추가

4. Mapper에 추가한 쿼리문 테스트(MemberMapperTests.java)

5. MemberService.java 추가

6. MemberController.java 회원가입 메서드 추가
	ㄴ사용자가 작성한 회원가입 정보를 MemberVO 클라스 타입의 member를 통해 데이터 받아옴.
	ㄴ회원의 정보가 담긴 member를 매개변수로 한 memberJoin() 메서드를 호출.
	ㄴ호출된 메서드를 통해 BOOK_MEMBER 테이블에 데이터를 INSERT 쿼리문 실행.

7. 아이디 중복검사 메서드 작성 및 테스트(Javascript)

8. ajax success 작성

9. email 전송, view(회원가입 페이지) 입력한 email 주소 Controller 전송
ㄴ데이터가 view에서 null로 넘어오면 controller에서 log를 찍거나 debug 해보기.

10. SMTP Server 메일 pom.xml/root-context(mailSender Bean) 등록.
	ㄴ1)인증번호 (난수, 메일 전송)
	ㄴ2)인증번호 입력란 변환, 일치여부 검사

	-인증번호-
	대부눈 int로 설정한 변수를 ajax를 통해 전송, 대부분 문자열러 변환하여 전송
	ajax에서 dataType : text 설정하면 'parseInt()' 함수 사용.

11. 주소 API 검색 -> 검색된 주소가 회원가입 주소란에 입력되는 것을 목표.
	우편번호, 주소 정보 해당 필드에 맞게 코드 수정하기(JQuery version)

12. 유효성 검사(입력란 미입력 방지)
	아이디, 비밀번호, 이름, 메일/인증번호, 주소 , 최종 유효성 검사 및 전송, 테스트

13. 로그인 (DB 요청하여 ID, PW 일치 여부 확인)
	ㄴ쿼리문은 제출받은 로그인, 비밀번호와 비교하여 일치하면 해당 아이디의 정보를 반환,
	ㄴ없을 시 null을 반환하도록 할 것.

	ㄴMemberVO(데이터 전달), 
	ㄴHttpServletRequest(로그인 성공시, session에 회원 정보 저장),
		ㄴ로그인이 되었다는 것은 session에 사용자의 정보를 저장하였다는 의미.
	ㄴRedirectAttribute(로그인 실패 시, 실패 정보 전달).

	ㄴ로그인 성공 시, 회원가입/로그인 버튼 사라짐, 회원의 정보만 노출.
	ㄴBCryptPasswordEncoder(비밀번호 된 인코딩, DB에 저장된 인코딩 된 비밀번호 일치여부)
	ㄴmember 객체에 저장된 비밀번호 꺼냄, encoder() 메서드를 사용하여 인코딩.
	ㄴ인코딩을 된 비밀번호를 member 객체에 다시 저장, memberJoin() 메서드 실행, 쿼리 실행
14. 로그아웃 

15. gnb_area 
	로그인 (<c:if> 태그를 통해 구분)
	ㄴ1)로그인하지 않은 상태('로그인', '회원가입', '고객센터'), 
	ㄴ2)로그인한 상태('로그아웃', '마이 페이지', '장바구니'), 
	ㄴ3)관리자 계정 로그인한 상태 
	
	로그아웃 (세션 제거 요청 방식을 비동기 방식으로 구현)
	ㄴ버튼 클릭 -> javascript 메서드 -> ajax 로그아웃 요청 -> server 로그아웃(화면 이동없이)

16. 인터셉터
	ㄴ일반 계정 or 로그인 하지 않은 계정이 관리자 페이지 접속 막기.
		ㄴ접속 메서드에 세션 체크를 통해 권한이 없는 관리자가 접근 시 메서드 실행되지 않게.
			ㄴ문제는 AdminController 모든 메서드에 적용해야 됨, 이를 interceptor해결

17. 작가 테이블/ 관리자 페이지/ footer 생성

18. 작가 등록  (server)
	ㄴ1)domain layer : AuthorVO 생성
	ㄴ2)persistance layer : AuthorMapper.xml/ AuthorMapper.java 생성
	   ㄴxml <insert> 태그의 id 속성 값은 AuthorMapper.java 작성한 등록 메서드명과 동일
	ㄴ3)business Logic layer : AuthorService.java / AuthorServiceImpl.java 생성
	ㄴ4)presentation layer : AuthorController.java 생성

    작가 등록 (client)
	ㄴAuthorEnroll.jsp  <form action="/admin/authorEnroll.do" method="post"id="enroll">
	ㄴ작가 등록에 사용할 데이터 AuthorVO 객체를 파라미터로 전달 받기 때문에, 
	ㄴVO클래스 변수 이름과 .jsp의 input, select 태그의 name/id 속성 값이 일치하도록 작성.
		ㄴxml query 문 변수와 DB Column명과 일치하는것과 같은 맥락.

19. 작가 목록 
	ㄴincludes - header/footer 구현
	ㄴpaging - criteria/pageMaker 구현
	ㄴ검색 인터페이스 구현 & 검색 결과 없을 시 view 처리 구현
20. 작가 상세 
	ㄴ목록 페이지와 마찬가지로 Criteria, pageMaker 구현
	ㄴ작가 목록 페이지에서 authorId 클릭시, 작가 상세 페이지로 이동, 이동 후, 목록/수정 버튼 구현
21. 작가 수정 
	ㄴMapper, Service, Controller 메서드 생성하지 않고, url mapping authorGetInfoGET()활용
	ㄴ@GetMapping({"/authorDetail", "/authorModify"}) 복수 url 구현
22. 상품 등록
	※ table ※
	ㄴauthorId, cateCode, joo_author table에 있는 데이터만 외래 키를 지정.
	ㄴ외래 키 등록은 작업의 편의를 위해서 특정 기능을 '상품 등록' 페이지에 적용한 뒤에 등록

	※ CateVO ※
	ㄴ컬럼 할인율(bookDiscount decimal(2,2))소수 둘째 자리까지 허용한 고정 소수점 타입으로 지정.
	ㄴ컬럼 책소개(bookContents) 경우 위지윅 활용을 위해 text type 사용.
	
	※ category ※
	ㄴ카테고리를 <select>/<option>설정할 수도 있지만, List 통째로 view에 전송/JSON타입으로전송
	ㄴ이번에는 JSON타입으로 변환(Jackson)하여 View로 넘기고, javascript 통해 가공하여 출력.
	ㄴ카테고리 코드 규칙, 책 상품을 3가지 단계로 분류(1단계, 2단계, 3단계) tier은 해당 단계 확인

	※ 팝업창 구현 ※
	ㄴwysiwyg editor/datepicker CDN 방식 적용.
		ㄴdatepicker 'autocomplete(<input>클릭시 이전 데이터 방지)' 'readonly'속성 추가
	ㄴ작가 팝업창 띄우기/작가 검색 후 선택할 인터페이스 구현/선택한 데이터goodsEnroll에 전달

	※ 카테고리 리스트 구현 ※
	ㄴ카테고리 리스트의 데이터를 JSON형식으로 SERVER -> VIEW 전송.
	ㄴJSON형식의 String 데이터를 활용하여 <select>, <option> 태그 구현.
	ㄴcateList 객체에는 '대,중,소'가 섞여 있는 상태, 이 객체를 tier에 맞게 분류하여 배열에 저장.
	ㄴ반복된 코드 메서드화 하여, 배열 초기화 후, 대/중/소분류 <option> 태그 출력.
	
	※ 유효성 검사 ※
	ㄴ변수를 두개로 나누어 구현하여 입력 값, 체크 변수를 통해 true/false를 이용하여 display 적용.

	※ 할인율 입력란 인터페이스 & 외래키 & 유효성 검사 설정 ※
	ㄴ사용자는 할인률 입력란 정수 입력, 서버에 전송은 해당 값을 소수로 변경 되도록,
		ㄴ할인율 입력란에 문자를 입력 못하도록 유효성 체크  
	ㄴ사용자가 제품 가격과 할인율을 입력하였을 때 할인된 가격 볼 수 있도록 구현.

	※ 상품 목록 페이지 구현 ※
	ㄴgoodsManage(상품 목록)페이지에 출력 시킬 column 은 
		'bookId', 'bookName', 'authorName', 'cateName', 'bookPrice', 'bookStock'
			문제는 'bookName', 'cateName' 열의 정보는 'joo_book' 테이블에 없다.
	ㄴ따라서 같이 출력 되도록 'JOIN' 사용

	※ 상품 조회 페이지 구현 ※
	ㄴ조회 페이지에는 상품의 이름 클릭시, 조회 페이지 이동과 함께, 선택한 상품에 관한 등록된 정보 출력.
	ㄴ'상품ID', '상품 등록 날짜', '상품 수정 날짜'가 출력되도록 코드를 추가.
	ㄴ각 <input>, <select> 태그에 사용자가 입력을 할 수 없도록 disabled 속성을 추가.
	ㄴ각 <input>, <textarea> 태그에 서버로부터 전달받은 상품 정보가 출력되도록 코드 추가.

	※ 카테고리 리스트 데이터 ※

23. 상품 수정
	※ 상품 수정 페이지 이동 ※
	ㄴ수정 페이지로 이동할 수 있는 인터페이스인 버튼과 페이지 이동에 사용될 URL 매핑 메서드를 작성.
	ㄴ <form> 태그 내부에 'bookId' 항목의 type이 hidden인 <input> 태그를 추가하였습니다. 				(수정을 수행하는 쿼리에서는 bookId가 필요로 하기 때문에 추가하였습니다.)
	ㄴ해당 <form> 태그는 수정 페이지에서 조회 페이지 이동할 때, 
		조회 페이지에서 목록 페이지로 이동을 할 때 필요로 한 데이터 들입니다. )

23. 상품/작가 정보 삭제 

24. 상품 이미지 업로드
	※ 상품 이미지를 업로드하고 등록한 이미지의 정보를 DB에 저장 ※

	방법1 : 이미지 업로드 저장
		ㄴ사용자가 이미지를 선택하였을때 이미지가 업로드(컴퓨터에 저장) 되고,
		   최종적으로 다른 상품 정보들이 작성된 뒤 '등록 버튼'을 눌렀을 때, 
		  '업로드 된' 이미지의 정보가 DB에 저장되도록 하는 방식
	방법2 : 등록 이미지 정보 DB 저장
		ㄴ사용자가 이미지를 선택을 하고 다른 상품 정보를 다 작성한 뒤,
		   '등록 버튼'을 눌렀을 때 이미지를 업로드하고, 업로드 이미지 정보를 DB 저장.

	-> 방법1 진행 
		1.사용자가 이미지 선택,
		2.선택된 이미지 서버로 전송,
		3.전송 받은 이미지 저장 후, 저장 한 이미지 정보 VIEW로 재전송,
		4.전송 받은 데이터를 활용하여 이미지 미리보기,
		5.<input> 태그에 데이터 저장,
		6.'등록 버튼' 클릭,
		7.이미지 정보 DB 저장

		(첨부파일 처리 servlet3.0 / 페이지 이동 없이, AJAX 사용)

	※ 파일 체크(Javascript) ※
	ㄴview 단계에서 사용자가 선택 한 파일이 개발자가 허용한 파일이 아닐 경우 경고창
		ㄴ허용한 파일(jpg, png) / 파일의 크기는 (1MB)

	※ 파일 객체 서버 전송 ※
	ㄴ이번 프로젝트는 화면의 이동 없이 첨부파일을 서버로 전송, FormData 객체 생성 후 저장하고 서버전송

	※ 업로드한 이미지 저장될 폴더 생성 ※
	ㄴ업로드 하는 날짜에 맞게 폴더 생성, 생성된 폴더에 업로드 파일 저장. (uploadPath.mkdirs() 사용.)
	ㄴAdminController/uploadAjaxActionPOST 에 파일을 저장할 기본적 경로 String 타입의 변수 선언.
	ㄴ'yyyy/MM/dd' 형식의 String 데이터를 얻기 위해 SimpleDateFormat 클래스와 Date 클래스 사용.
		ㄴSimpleD은 Date 클래스를 통해 얻은 날짜 -> 문자열 형식의 데이터로 변환하기 위해서 사용.
	ㄴ고유한 파일들을 관리하기 위해 저장 파일에 UUID 추가.

	※ 썸네일 이미지 생성 및 저장 ※
	ㄴ이미지 호출 시, 썸네일 이미지를 호출 할 수 있도록 원본 이미지를 통해 썸네일 이미지를 생성하고 저장
		ㄴjava 클래스에서 제공하는, ImageIO, Thumbnailator 사용
			ㄴ저장될 썸네일 이미지 경우 "s_" + "uuid_" + "원본파일 이름. 이미지 타입" 형식으로 저장.
				ㄴMultipartFile/BufferedImage/ImageIO/Graphics2D 클래스 사용하여 이미지 파일 저장.
					ㄴImageIO 대신 thumbnailaotr라이브러리 사용하여 코드 간결화.
	
	※ 이미지 정보 view 반환 ※
	1.왜 이미지 정보를 view로 반환하려 하는가? 
		ㄴ업로드한 이미지 정보를 DB에 저장하기 위해 & 업로드한 이미지를 사용자가 미리 볼 수 있도록.
			ㄴ'경로', 'uuid', '파일 이름' 3가지 데이터를 DB에 보관, view로 전송,
				ㄴview 전송은 Command Object 객체를 view에 전송. (AttachImageVO 객체 생성)
	2.어떠한 정보를 보낼 것인가?
		ㄴDB 저장 -> 이미지 화면 출력 -> 이미지 저장 경로/파일 이름 필요.
			ㄴC:\upload + '유동적 경로' + 's_' + 'uuid' + '_' + '원본 파일 이름'
	3.어떠한 방식으로 view에 데이터를 전송할 것인가?
		ㄴ화면의 이동 없이 서버와 뷰가 정보를 주고 받는 비동기 방식 사용.(@ResponseBody/ResponseEntity )
	4.여러 개의 이미지 파일 전달을 위해 ArrayList 활용, for문에서  VO 정보를 저장한 다음 해당 객체, ArrayList 		요소에 저장

	※ 서버 단계 이미지 파일 체크 & view 에러 반환 ※
	ㄴview에서는 이미 파일체크를 하도록 코드를 작성 하지만 파일체크 코드가 작동 안 할시 차선책 구현.
		ㄴ업로드를 수행하는 url 매핑 메서드에도 전달 받은 파일 체크 하는 코드를 추가.
			ㄴ파일 체크 시, 아닐 경우 에러 상태 코드를 전송하여, view에서 경고창이 출력.
				ㄴ파일 체크를 위해 MIME TYPE 속성 활용, probeContentType() 반환 메서드 사용.
				ㄴMIME TYPE 타입이 이미지일 경우, 첫 단어가 image로 시작, 이 방법으로 판단.
					ㄴview에서는 ajax의 error 속성을 추가하여 상태코드 400시, 콜백함수를 사용.
	
	※ 업로드 이미지 출력 구현 ※	
	1.url 매핑 메서드 반환 & ContentType 명시
		ㄴ비동기 방식 url을 호출하면 이미지를 반환해주는 url 매핑 메서드를 구현(미리보기 이미지 구현위해)
		   @ResponseBody & @ResponseEntity 중, body에 데이터를 첨부한다는 동일,
		   하지만 @ResponseEntity를 사용하여 header의 'ContentType' 이미지 파일임을 명확하게 설정,
		ㄴurl 메서드 '파일경로' + '파일 이름' 파람으로 받고, 해당 데이터에 맞는 이미지파일 view에 전송.
			ㄴ이미지 파일을 주고받기 위해서는 byte 배열 타입 사용.
			  (이미지 파일은 binary(0과 1로만 구성, text 제외 한 모든 파일 저장) 파일 해당,)   	   
	2.file 객체 생성
		ㄴ현재 관리자 관련 기능들을 구현주잉여서 AdminController에 작업을 진행하려 했으나,
		   관리자가 아닐 시, Interceptor 필터를 거쳐야 하기 때문에 접근에 제한.
		   이미지는 비로그인이여도 접근이 가능해야 하기 때문에, 상품 BookController.java에 작성.
	
	정리 -> 파라미터 전달받은 '파일 경로', '파일 이름' 활용하여 File 객체 생성,
		    MIME TYPE에 대한 정보를 얻어, ResponseEntity img 데이터를 복사하여 body에 추가,
		    header의 'Content Type'에서 얻은 정보를 MIME TYPE으로 수정 후, Entity 객체를 view로 전송.

	고정 경로 http://localhost:8080/display?fileName=test.png
	유동 경로 http://localhost:8080/display?fileName=2024/01/21/test.png

	※ 업로드 이미지 선택 시, 이미지 미리 보기 ※ 
	ㄴ업로드 이미지 요청 데이터(path, filename, uuid)를 받았을 때, ajax success 콜백 함수 이미지 데이터 출력.
		ㄴ코드 양이 길어서 메서드를 선언하여, 구현부에 이미지를 출력하는 코드 작성하여 함수 호출.
			ㄴ메서드를 미리 호출하고 인자 값으로 서버로 전달받은 result(path, filename, uuid) 부여.

	※ 이미지 삭제 기능 구현 ※
	1.File 클래스의 delete() 메서드 사용.
	ㄴFile 클래스 인스턴스화.
	ㄴ생성자에 대상 파일의 경로인 문자열 데이터를 파라미터로 부여, 
		ㄴ삭제할 대상의 파일의 경로가 필요, url 매핑 메서드의 파라미터로 fileName 부여.
	
	2.썸네일 파일 삭제 (미리보기 이미지의 우측 상단의 x표시 클릭 시, 삭제)
	ㄴencodeURIComponent() 메서드를 통해 UTF-8로 인코딩 된(썸네일 이미지 파일) 데이터 전송.
	ㄴ문자열 데이터는 "/" or "\" 구분하는데, UTF-8로 인코딩 되었기 때문에, 데이터 자체만으로는 삭제 불가.
		ㄴ따라서 fileName에 담긴 데이터를 Decoding 해서 해당 데이터 삭제.

	3.삭제 버튼 태그 data 속성 삽입
	ㄴimgDeleteBtn <div> 태그에, 해당 파일 경로 데이터를 심어 놓기.
		ㄴdata-file 속성을 추가하고, UTF-8 인코딩해둔 변수(view에서 전달 해준 파일 decode)를 사용.
	
	※ 미리보기 이미지 제거 및 서버에 이미지 파일 삭제  ※
	삭제 메서드 기능이 적용되어야 할 상황이 두 가지.
	1.미리 보기 이미지의 'x'를 클릭 시, 삭제.
	2.이미지가 등록될 때 파일이 이미 존재를 한다면  삭제를 처리한 후 서버에 이미지 업로드 요청.
	ㄴ두 가지의 파일이 저장되게 되고, 미리보기 이미지도 두 가지 출력, 사용자가 이미지를 선택 시, 파일삭제

	삭제 메서드 진행 순서
	1.서버에 파일 삭제 요청
	2.서버로부터 응답에 따른 처리
	3.서버로부터 응답에 따른 처리 성공 시, 미리 보기 태그를 지우는 작업 / 실패 시, 경고창 띄우기.

	★★★★★ 업로드 이미지 정보 등록 ★★★★★
	- view에서는 상품 하나에 하나의 이미지만 추가 하지만, 서버에서는 여러 개의 이미지 처리도록 코드 구성.
		따라서 이미지 정보를 따로 관리 할 수 있도록, 새로운 테이블 생성, bookId라는 컬럼을 추가하여,
		해당 컬럼은 오직,joo_book 테이블의 bookId 에 존재하는 데이터만 등록 가능 하도록 외래키 설정.

	※ 서버 등록 ※
		ㄴ서버에서는 여러 개의 이미지 등록 가능하도록 List 구조의 AttachImageVO 타입 변수 선언.
			ㄴimageEnroll(Mapper 단계)는 하나의 이미지, bookVO 클래스는 여러 이미지 List 타입.
				ㄴimageEnroll이 데이터를 처리 할 수 있도록, imageList 요소 하나씩 for문 사용하여 넘김.

		ㄴ기존 등록 메서드는 Service 단계에서 새로 작성 했지만, Mapper 단계의 메서드에서 호출.
			ㄴService 단계의 기존 bookEnroll() 메서드에서 imageEnroll() 메서드를 호출.
				ㄴimageList() 메서드는 List 타입, 따라서 for문을 이용하여 각 요소 크기만큼 데이터 처리.
					ㄴServiceImpl 클래스에 람다식을 이용하여, bookEnroll()에서 imageEnroll 호출.
			ㄴbookEnroll() 는 view 로 부터 전달받은 데이터를 BookVO 통해, 상품/이미지 정보 DB에 등록

			문제점 : imageEnroll() 쿼리문에는 'bookId' 가 반드시 필요, 하지만 (외래키 설정 때문에)
					서버로 부터 전달받은 BookVO 객체에는 'bookId' 데이터가 없다.

			해결 : bookEnroll() 먼저 호출을 하고, 해당 메서드에는 '상품 정보' 쿼리 삽입 동시에,
					새롭게 부여되는 bookId column 값을 BookVO 객체의 bookId 변수에 반환.
						ㄴ반환받기 위해 MyBatis의 <selectKey> 태그 활용.
							ㄴ반환받은 'bookId' 정보를 활용하여 이미지 정보 DB 등록을 처리.

		 ㄴ<selectKey> 
			문제점 : order 속성값이 "BEFORE" 이고.INSERT문이 실행 되기 전에 <selectKey> 쿼리문이 실행.
				ㄴ가장 최근 등록한 row를 삭제 후, 새로운 정보 추가했을 때, bookId 값과 반환 값 불일치.

				ex)'bookId'가 3107인 행을 지우고 새로운 행을 추가했을때, 'bookId'가 3108인 행이 추가
					되지만 <selectkey>를 통해 반환받은 결과는 3107 혹은 더 작은 값입니다.

			해결 : order="AFTER" 로 바꿔주고, 쿼리문 MAX(bookId) +1 ->  MAX(bookId) 코드 변경.
					(INSERT문이 실행 된 후, <selectKey> 쿼리문 실행.

		※ transaction 적용 ※
			ㄴbookEnroll() 메서드에서 두 개의 쿼리 작동 시, 하나의 쿼리라도 발생 시, 예외 상황 발생도록.
			ㄴserviceImpl 클래스에 @Transaction 미적용/적용 시, Junit 작동하여 차이점 알아보자.
				실험 : img1 객체에는 정상 코드, img2 객체에는 고의 적인 에러 발생 하도록 코드 구현.
				@Transaction 미적용, DB에서 img1 쿼리,작동하여 데이터가 전달, img2 데이터는 미전달
				@Transaction 적용, DB에서 예외 상황 발생하여, img1, img2 작업 모두 취소.
	※ view 등록 ※
		ㄴ<input>태그 추가하기 앞서, 주의점 세 가지
			1.javascript를 통해 동적으로 추가, 이미지가 등록되었을 때, 서버에 이미지 정보 전달.
			2.<input> 태그 추가 시점, 두 가지 시점
				ㄴ1)이미지 등록 후 미리보기 태그 추가될 때(ajax의 success 속성 동작 시점).
				ㄴ2)상품 등록 페이지 버튼을 눌렀을 때, 서버에 데이터가 전송되기 전.
					ㄴ여러 개의 이미지를 전달할 시에 '상품 등록 버튼을 눌렀을 때', <input> 태그를
						추가하는 것이 용이하다.
					ㄴindex를 활용하여 name 속성 값을 작성해야하기 때문이다.
					ㄴ'상품등록 버튼을 누른다는 것은 등록할 이미지가 확정이 된 상태이기 때문에
						등록된 이미지 개수만큼 for문을 통해 index를 지정해주면 된다.
			3.<input> 태그의 어떤  name 속성 값 선언 할 것인지.
				ㄴ기존 name 속성 값들은 BookVO의 멤버 변수명을 그대로 작성하면 되었다.
					하지만, 이미지 정보의 경우 객체의 주소 값이 참조 변수이어서, java에서 특정
					클래스의 멤버 변수에 접근할 때 "참조변수.멤버변수" 로 작성 해주어야 한다.

				ex) BookVO에 'private AttahImageVO imageVO; 변수를 선언, fileName을 전달 위해서는
					<input> 태그의 name 속성 값 "imageVO.fileName"으로 작성 해주어야 한다.

		ㄴgoodsEnroll.jsp, 즉 view 단계에서는 하나의 이미지 파일만 등록할 수 있도록 구현하고 있기 때문에,
			이미지가 등록된 시점에 이미지 정보 <input> 태그가 추가 되도록 작업.

25.상품 상세(관리) 페이지 이미지 출력
	방향 : 이미지를 등록한 상품의 상세 페이지에 DB 저장된 이미지 정보를 활용하여 이미지 출력.
		
	방법 : '상세 페이지'에 이미지 정보를 어떻게 전달해줄 것이냐?
			1.상품 페이지 이동할 떄, 상품에 대한 정보/이미지 정보를 함께 넘겨주는 것, 
			2.상품 상세 페이지 이동 후, AJAX/getJSON 을 이용해 이미지 정보 요청.

	-이번 프로젝트는 getJSON 을 사용한 이미지 요청 방식 채택.
		ㄴ서버 측에서 이미지 정보를 반환해주는 URL 구현.
			ㄴ작성한 URL을 요청하여 이미지 정보를 반환받은 후 이미지 출력.

26.상품 이미지 수정
	part 1.
	방향 : 상품 수정 페이지에서 상품의 이미지가 없다면 이미지 등록, 
			기존 이미지가 있다면, 새로운 이미지를 등록 한 뒤, '수정 버튼' 클릭 시, DB와 서버에 저장.
			
	방법 : 이미지 수정 구현은 기존과 다르게, 이미지 데이터를 삭제하고 추가해주는 작업이다.
			1.'이미지'가 저장되는 서버			
			2.'이미지 정보'가 저장 되는 DB  
				DB 측면
				1)view 삭제 할 이미지 선별, 서버로 전송, 해당 이미지 정보에 행만을 지움.
				2)view에서 전달 받지 않고 수정할 대상 상품과 관련된 이미지 정보를 모두 지움,

				SERVER 측면
				어떠한 타이밍에 서버에 저장된 파일을 삭제하고 추가해줄 것인가.
					ㄴ단순하게 삭제/수정 버튼을 누르면 이미지가 삭제/저장 되는 방식인데,
						이 문제점은 사용자가 정확히 개발자의 의도에 맞게 행동해야만 한다라는 문제.
					ex)사용자의 여러사유로 '수정버튼'을 누르지 않고, 해당 페이지를 벗어날 경우,
					    삭제한 이미지 정보는 DB에 남겨져 있고, 새로 추가한 이미지의 정보는 저장 안됨. 

				
				1)서버에서 이미지 삭제와 추가 작업을 '수정버튼'이 눌렀을 때 이루어지도록 구현.
				2)사용자가 수정을 하는 과정에서 서버에 저장된 파일에 대한 삭제 작업은 하지 않고,
					추가 작업만 해주는 것, 대신 DB에 등록된 이미지 정보와 서버에 저장된 이미지 정보
					비교하여 DB에 등록되지 않은 이미지가 있다면 해당 이미지들만 삭제해주는 것.
				
				-> 2) 방식으로 배치 프로그램을 사용하여 구현.

	정리 
	ㄴview 
		1.기존에 저장되어 있는 이미지가 있다면, 사용자가 볼 수 있도록 출력.(기존 정보 담긴 input 태그작성)
		2.출력된 이미지에는 삭제 버튼이 있다.
		3.삭제 버튼을 누르면 서버에 저장된 이미지에 대해 서버에 요청 않고, 이미지 출력 태그, input태그 삭제
		4.사용자가 새로운 이미지를 추가하면, 서버에 이미지 저장을 요청, 서버는 저장 후, view로 다시 반환.
			view는 반환받은 이미지 정보를 통해 이미지 출력이 되도록 태그 추가하고 input 태그 저장.
		5.수정 버튼을 누르면 수정된 상품 정보와 함께 이미지 정보를 서버로 전송.

	ㄴserver
		1.view에서 이미지 저장 요청이 있을 경우, 서버에 이미지를 저장하고 해당 이미지 정보 view로 반환.
		2.view에서 수정 요청이 들어오면 전달받은 수정 상품 정보와 이미지 정보가 담긴 BookVO객체를 이용.
		3.상품 정보에 대한 수정 작업을 진행한 후, 상품 이미지 정보 수정 작업을 진행.
		4.상품 이미지 작업은 해당 이미지 정보를 모두 삭제한 후 view로 전달받은 이미지 정보를 등록해준다.

	part 2.
	ㄴpart1에서는 수정된 상품 / 이미지 정보를 서버로 전송하는 것 까지 완료. [client -> server]
		part2에서는 DB에 수정된 정보가 반영이 될 수 있도록 서버 단계에서 작업. [server -> db]

	방향 : 기존 goodsModifyPOST 메서드는 DB 수정된 정보가 반영 되도록 serviceImpl의 modify 호출한 뒤,
			성공 여부 결과 값을 반환받아서 이를 "result" 속성 값으로 부여해준 후, 목록 페이지로 이동.
		-service 단계의 serviceImpl의 modify 메서드가 수정한 이미지 정보 또한 DB에 반영할 수 있도록.

		ex) 상품 정보 쿼리 수정
			-> 수정 실패 -> 실패 반환
			-> 수정 성공 -> 해당 상품 이미지 정보 전체 삭제
					   -> view로 전달받은 이미지 정보 등록
					   -> 수정 성공 반환
	
	part3 (배치 프로그램 적용)
	방향 : 서버 내부에서 주기적으로 DB에 이미지 정보가 존재하지 않는 이미지 파일 삭제
	방법  1-1) DB에 존재하는 이미지 정보 리스트 가져오기.
			ㄴPath 객체로 변환하여 List 자료구조에 저장.
		1-2) Directory에 존재하는 이미지 정보 리스트 가져오기.
			ㄴ폴더에 저장된 데이터를 얻기 위해 File 클래스의 "listFiles()" 메서드를 활용.
				listFiles()을 호출, 해당 디렉토리에 저장된 파일들을 File 객체 요소를 가진 배열로 반환.
				Paths 클래스 get() 사용, directory의 path 객체를 얻고, toFile() 호출, path 객체 File객체 변환
		2) 서버에 저장된 이미지 리스트 가져오기
		3) 두 개의 리스트를 비교햐어 DB리스트에 존재하지 않는 서버 이미지 리스트 분류
		4) 해당 리스트의 이미지 파일 삭제
		5) 범위는 하루 단위의 이미지 파일들을 체크할 대상으로 상정(이미지 파일들은 날짜 값을 이름으로가짐)

	정리 : DB에 저장된 어제자 날짜의 이미지 정보/이미지 파일 리스트를 가져오고, 리스트를 가져온다. 
		두 리스트를 비교, DB리스트에 존재 않는 서버 이미지 리스트를 분류하여 해당 리스트의 파일들을 삭제.

27. (이미지 존재) 상품 정보 삭제 에러 보완 (참조 무결성 위반)
	문제 : 이미지가 존재하는 상품 수정 페이지에서 삭제 버튼 클릭 시, 500 에러 발생.
	이유 : a foreign key constraint fails (`bookshop`.`joo_image`, 
			CONSTRAINT `joo_image_ibfk_1` FOREIGN KEY (`bookId`) REFERENCES `joo_book` (`bookId`))
		ㄴ참조 무결성 발생 (joo_image 'bookId' 가 joo_book 'bookId' 참조하고 있어서 삭제 시, 에러 발생.)

	방안 : joo_image table row 삭제 한 뒤, joo_book table row 삭제 or 외래키 설정 시, ON DELETE CASCADE
			ㄴ첫 번째 사용 + 서버에 저장되어 있는 이미지 파일 삭제
						ㄴ상품 정보가 삭제될 때 서버 이미지 파일도 같이 삭제.
	정리 : 상품 정보 삭제 = 상품 정보 + DB 저장된 이미지 정보 + 서버에 저장된 이미지 정보

	방향 : goodsDeletePOST 활용, 1)서버 이미지, 2) DB (상품+이미지 정보) 삭제 순으로 구현

28. 검색 구현
	방향 : 기본적인 '책 제목' / '작가' 검색 + 메인 페이지에서 각 카테고리가 출력되어 있는 네비 링크를
			클릭 시, 해당 카테고리의 상품이 검색이 될 수 있도록.
		'기본적인 검색 기능' -> '조건 검색(작가, 카테고리) 기능' -> '메인페이지 카테고리 네비 링크' 순으로 

	part1(기본적인 검색 기능)
		view
		ㄴ키워드에 대한 데이터와 검색 결과 (amount(10), pageNum(1)) 에 대한 데이터를 서버에 전송
		ㄴmain.jsp 검색 (!list.isEmpty()), 서버에서 반환받은 데이터(list = empty) 보낼 search.jsp html 구현

		server
		ㄴkeyword, amount, pageNum 을 사용하여 DB에 검색 결과 데이터를 가져온 후, 클라이언트에 전송.
		ㄴmapper.xml criteria(조건검색), include refid="criteria" 포함한 상품검색, 상품 총 갯수 query 구현.
		ㄴBookController 에 상품 검색 로직을 만들고, 상품 리스트 empty(), !list.empty() if문으로 나누어 구현.

	part2(조건 검색 구현 - MyBatis 문법을 이용한 동적 쿼리 구현)
	 방향 : 기존 쿼리 조건 '책 제목'에서 추가 ( '작가', '카테고리', '카테고리 + 작가', '카테고리 + 책 제목' ) 검색.
	 문제 : 가장 간단한 방법은 검색 조건에 맞는 쿼리문 모두 작성 -> 코드 낭비 (비효율적)
	 보안 : 변경되는 부분은 코드의 일부분, 동일한 코드 반복 -> MyBatis의 문법을 이용하여 동적쿼리 작성.
		
	part3(동적쿼리 테스트 중, 조건에 맞지 않은 데이터 결과가 검색되지 않을 떄)
	 문제 : 1)조건에 맞지 않은 데이터를 부여한 경우에는 console 창에 빈 값 들만 찍히게 된다.
		  2)검색 조건이 있는 경우에는 검색조건과 상관없는 데이터들이 나타난다.
	 이유 : 작가 정보의 경우 getAuthorIdList() Mapper 메서드로부터 반환받은 데이터를 활용해서 동적 쿼리에
		  사용이 되는데, 작가 정보가 없는 요소가 없는 빈 배열 객체가 MyBatis 쿼리문에 전달되어서 작가 
		  조건문이 추가되지 않은 쿼리문이 사용되게 되기 때문이다.
	 보안 : MyBaits 쿼리문에 <if>, <choose>, <when> 태그를 추가하여 보완 가능, 하지만
			getAuthorIdList() Mapper 메서드의 결과가 요소가 없는 빈 배열을 반환하게 된다면, 검색 쿼리 
			결과도 없어야 하는 것이기 때문에 Service 단계에서 빈 배열 반환할 시, Controller에 요소가 없는
			빈 List 를 반환하도록 코드 추가.

29.상품 목록 화면 구현 
	part1('상품 목록 화면' 출력)
	 방향 : 검색을 통해서 필요로 한 상품 정보를 '상품 목록 화면(search.jsp)로 뿌렸다. 이번에는 화면 출력.
			1.검색 쿼리 컬럼 추가
			2.검색 결과 데이터 & 페이지 이동 인터페이스
				ㄴ책 이미지, 정보, 평점, 가격 구성
			3.출력 데이터 형식 변경

	part2(출력 데이터 형식 변경)
	 방향 : 검색 결과 인터페이스 구현
		1.검색 화면에 할인에 대한 정보도 전달하기 위해서 BookMapper.xml 쿼리(select bookDiscount 추가.)
		2.'책 이미지/정보/평점/가격' , 페이징 데이터를 인터페이스에 출력.
			ㄴ가격을 한국 '원' 패턴으로 설정하기 위해 fmt 사용
		3.검색 option type(작가/책 제목) 별 selected 속성 부여해주는 코드 구현.
	
	part3(상품 목록 화면에 상품 이미지 출력)
	 방향 : 상품에 대한 이미지 출력과 없다면 없다는 이미지 출력.
	 문제 : BookController 클래스에 "/display" 메서드를 호출, fileName(경로+/s+uuid+파일이름)을 서버에 전송
			ㄴ그러나 현재의 목록 페이지 view에 전달한 "list" 객체엔 상품 이미지에 대한 정보를 포함x
	 보안 : 상품 리스트에 대한 정보를 담고 있는 "list"에 상품 이미지에 대한 정보가 함께 담길 수 있도록 구현.
			ㄴgetGoodList() 수정, BookVO는 List 자료구조에 담아서 반환, 추가로 이미지 정보도 포함.
				ㄴ새로운 변수 생성x, AttachImageVO 타입의 이미지 정보가 저장된 변수 imageList 사용.
	 정리 : Service 단계의 메서드가 BookVO의 imageList 변수에 이미지 정보를 저장하도록 하는 코드를 추가.
			ㄴ상품 이미지 정보를 DB로부터 가져오는 Mapper 메서드가 필요.

30.메인화면 네비 기능
	 방향 : 사용자가 카테고리 이름을 클릭했을 때 해당 카테고리로 구성된 상품의 목록 페이지로 이동	 
		
		ㄴview 
			- 사용자가 메인 페이지 접속 시, 카테고리 데이터 나열.
			- 사용자 원하는 카테고리 클릭 시, 해당 정보를 서버에 전송하여 관련 리스트 요청.
			- 메인 페이지(main.jsp), 검색 후 페이지(search.jsp) 두 가지 처리.
		
		ㄴserver
			- view에서 전송한 카테고리 정보를 DB에 요청. (controller의 "/seach" url 사용)
			- DB로부터 요청한 정보를 반환 시, view로 전송.

31.검색 필터링 기능.
	 방향 : 상품 목록 인터페이스에는 키워드 검색 시, 속한 상품이 '카테고리', '개수'가 표시된다. 
		  카테고리 이름을 클릭 시, 해당 카테고리로 필터링된 상품 목록으로 이동.

	 	  1) '책 제목/ 작가 이름' 검색 했을때 만, 기능 되도록 구현.
		  2) 사용자가 검색한 키워드를 가진 상품이 속한 카테고리 이름들이 출력됨.
		  3) 카테고리 이름 옆에 카테고리에 속한 상품 수가 출력됨.
			ㄴCateVO에는 '개수'가 없기 때문에, 새로운 VO(CateFilterDTO, int cateCount) 생성.
		  4) 필터 클릭 시, 기존 필터링 데이터 그대로 존재. (사용자가 새로운 키워드 검색 시, 변환)
		  5) 카테고리 이름 클릭 시, "/search" url 타고, type, cateCode, keyword는 파라미터로 서버에 전송.

	 	 

32.상품 상세 페이지
	 방향 : 상품 검색 페이지 or 다른 경로를 통하여 이동할 수 있는 '상품 상세 페이지' 구현을 목표
		
		  1)ServiceImpl.java에서 기존 BookVO 타입의 객체를 getGoodsInfo() 메서드를 통해 상품정보 가져옴.
		  	추가로 상품 정보와 상품 이미지도 함께 가져오기 위해 getAttachInfo() 메서드를 가져온다.
		  2)Controller.java의 @GetMapping("/goodsDetail/{bookId}") 
			템플릿 변수 {bookId} = 요청 / @PathVariable("bookId") = 처리를 담당.

		  @GetMapping("/goodsDetail/{bookId}") 
		  public String goodsDetailGET(@PathVariable("bookId") -> "/goodsDetail/15"
		  ㄴURL 경로에 작성된 식별자 값 "15"가 추출되어 파라미터 변수 'bookId'로 대입
	
33.장바구니 기능 (교보문구 페이지 참고)
	 방향 : 1)등록
			-회원은 원하는 상품 '장바구니'에 등록.
			-장바구니 등록은 '상품 페이지' 버튼을 통해서만 등록 가능.
			-기존 등록 상품을 중복 등록 할 경우 경고창 생성. 
				ㄴMYSQL 에서 unique 제약조건을 적용하여 INSERT 중복 발생 방지.
		  2)수정
			-장바구니 페이지에서 상품의 수량 변경 후, 버튼 클릭 시, DB에 등록된 수량이 변경 된다.
			-변경 후, 장바구니 페이지로 리다이렉트
		  3)삭제
			-장바구니 페이지에서 삭제하고자 하는 상품의 '삭제 버튼' 클릭 시, DB에 등록된 데이터 삭제.
			-삭제 후, 장바구니 페이지로 리다이렉트
		  4)페이지 이동
			-비로그인 사용자가 장바구니 링크 or 페이지 클릭 시, '로그인 페이지'로 이동.
			-장바구니 등록된 페이지에 상품들을 선택 후 '구매 버튼'을 누르면 '구매 페이지'로 이동.

	 Table 구현 방향 
		1)하나의 '장바구니 상품'은 한 명의 '회원'에 속해야 한다. 하지만 '회원'은 여러 개의 '상품'을 가짐.
			ㄴ장바구니 테이블에 외래키 memberId 를 설정.
		2)'상품'은 하나의 정보를 가지고 있고, 반대로 '상품'은 여러 '장바구니'에 속할 수 있다.
			ㄴ장바구니 테이블에 외래키 bookId 를 설정.

	 Server  
		-view로 부터 '장바구니 추가' 요청을 받고, DB에 등록할 데이터 (memberId, bookId, bookCount) 받음
		-전달받은 memberId/bookId와 동일한 데이터를 가지는 joo_cart 존재 확인, 없을 시 insert
		-화면의 이동이 없는 비동기 방식으로 view는 요청하도록 할 것이기에 http body에 바로 데이터 삽입.
		-view는 숫자를 반환받도록 한다.(0:등록실패 / 1:등록성공 / 2:등록된 데이터 존재 / 5:로그인 필요)
	 Interceptor
		-"/cart" url 경로를 타는 모든 요청은 Interceptor를 거치도록 하였습니다.
		-'장바구니 등록'메서드는 로그인에 관해서도 체크하여 그 결과를 반환하도록 구현.
		-"/cart/add" 요청에 대해서만 interceptor를 거치지 않도록 설정을 변경해야 한다.
			(<exclude-mapping path="/cart/add"/>)
		-addCart()에 throws Exception 예외 추가 (어떤 예외 상황인지 구분위해)
	view
		-jsp 페이지에서 'memberid', 'bookId', 'count', 데이터 값 세팅	
		-"/cart/add" url로 '장바구니 추가'를 요청하여 세팅한 값을 서버로 전송
		-서버가 반환 값에 따라서 경고창을 띄우는 것이 목표.

34.장바구니 페이지 (교보문구 페이지 참고)
	방향	: 로그인한 사용자의 화면 오른쪽 상단의 링크를 통해서 들어갈 수 있도록 할 것.
	구현 페이지
		1) 사용자의 장바구니 정보의 출력.
			ㄴcartDTO.java 변수 출력.
		2) 사용자의 장바구니 정보를 종합한 정보 출력.
			ㄴ총 가격/ 개수/ 종류/ 마일리지/ 최종 가격/ 배송비(30,000 <= 3,000원 / 30,000=> 0원)
		3) 사용자가 상품 선택을 할 수 있도록 checkbox 구현과 그에 따른 종합 정보 변경.
			ㄴ체크 상태에서 '주문하기' 버튼을 누르게 되면 상품만 주문이 이루어질 수 있도록.
			ㄴ장바구니 상품 페이지에서 '종합 정보' 체크가 변경될 때마다 실시간 변경
		4) 각 상품의 이미지 출력.
			ㄴcartDTO에 List<AttachImageVO> 타입의 변수를 만들고, Impl class에 DI 주입시킨다.
		5) 사용자가 제품을 구매할 경우 포인트 or 마일리지 동적인 변동 구현(view에서 구현).
			ㄴ1.구매 시 받을 수 있는 '포인트' 출력(할인판매 가격의 5%).
			ㄴ2.장바구니의 데이터를 전달해주는 역할 DTO에 '포인트' 추가.
		6) 장바구니 수량 수정	
			ㄴ상품란에 수량을 변경 후, 'joo_cart' DB의 수량이 변경 되도록 구현.
		7) 장바구니 삭제 

35.주문 구현 방향
	 방향 : 1) 사용자가 선택한 물품(장바구니 or 바로 구매)을 주문하는 기능
			ㄴ장바구니/물품 페이지(바로구매) 선택 시, '주문 페이지' 이동.
			ㄴ주문자의 배송 정보(주소, 이름)을 입력하고 사용할 '포인트' 입력.
			ㄴ사용자가 주문 버튼 클릭 시, (재고/돈/포인트) 차감 되고, 주문 상태가 '배송 준비'로 바뀜
			ㄴ주문이 정상적 완료되면, '메인 페이지'로 이동.
		 2) 주문 취소 기능.
			ㄴ개인 페이지가 없기에 단순화 하기 위해서 '관리자 화면'에서 '주문 현황'을 통해 취소.
	
		 3) 테이블 설계에서 '다대다 관계'는 논리적 설계는 가능하나, 물리적 설계에서는 불가, 문제 발생
			ㄴ중간에 주문_상품 매핑 테이블을 넣어주어서 문제 해결.

			+주문 기능 예외처리 db에 등록된 상품의 수량이 주문한 수량보다 적을 시 예외(시도해보기)

36.주문 페이지 구현 (교보문구 페이지 참고)
	 방향 : 1)회원정보 - 회원의 이름, 연락처 기재
		  2)배송지 정보 - 회원 정보에 저장된 배송정보 or 직접 입력 (daum 우편번호 사용)
		  3)주문 상품 정보 - 사용자가 주문하고자 하는 상품의 정보
			ㄴ3개의 <td> 태그를 이용(1. 이미지, 2.상품 이름 3.가격)하여 상품 정보 제공.
		  4)포인트 사용 유무 - 회원의 사용 가능 포인트(maxPoint) & 사용하고자 하는 포인트 입력
			ㄴ포인트 입력란에 회원이 가진 포인트 모두 사용 or 사용 취소 가능하게 구현.
		  5)최종 주문 정보 - 최정 결제 비용 정보(포인트 사용량에 따라 변화되는 코드 적용)
			ㄴ주문 물품은 확정이기 때문에 변동x 그러나 포인트로 인한 결제 비용 변동.
		  6)상품 이미지
			ㄴ주문 페이지 상품란에 이미지 삽입.

37.주문 기능 구현
	 방향 : View
		 1)'주문 페이지'에서 '결제하기' 버튼 클릭했을 때 서버에서 처리
			ㄴ서버에 넘겨줄 데이터(배송지 정보, 사용 포인트, 주문 상품 정보 = 주문전송 form 작성.)
		 2)'주문 종합 정보' 섹션은 사용자의 주문 정보에 다라서 사용자가 지불해야 할 비용 정보를 보여준다.
			ㄴ장바구니에서는 회원이 체크한 물품에 따라 '종합 정보'가 변경
				ㄴ주문에서는 '포인트'에 따른 '종합 정보'가 변경.		

		 Sever
		 1)'주문'처리 작업에서 생성할 Mapper 메서드는 6개
			ㄴ하나의 주문 요청이 들어왔을 때 6개 이상의 쿼리문이 나간다.
		 2)사용할 데이터를 세팅 (회원 객체, 주문 객체)
		 3)주문 데이터 DB에 등록
		 4)비용, 포인트 변동 DB 적용
		 5)재고 차감 DB 적용
		 6)장바구니 상품 정보 DB 제거
		 7) Controller에서 회원 정보의 session 인 "member" 최신화(변동된 데이터(돈, 포인트)를 적용				
		 DTO
		 -OrderItemDTO :	 '하나'의 '주문 상품 정보' ('상품 할인율', '상품 가격')		
		 -OrderDTO	       : '주문 상품 정보' ('배송지 정보', '사용 포인트', '여러 개') 			
			ㄴ주문 작업에 필요한 정보(배송비, 최종 비용(상품비용 + 배송비 - 사용 포인트)) 

		 -view에서server로 전송할 정보, db에 꺼내올/등록할 정보, 비즈니스 로직 처리에 필요 정보를 담는다.

38.주문 현황 구현	
	 방향 : '관리자 페이지'에서 주문 현황을 볼 수 있는 페이지 구현을 목표.
		 1)사용자가 링크 클릭 시, DB에 등록된 주문 정보가 출력이 되도록 구현.
		 2)회원 아이디를 검색 할 수 있도록 '검색' 기능 구현.(페이징의 검색 기능 참고하여 구현.)







